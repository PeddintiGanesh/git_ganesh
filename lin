Experiment 1:
Simulate the Following CPU Scheduling Algorithms:
Aim:  (A.) Write a C program to implement FCFS scheduling mechanisms  
Algorithm:
Step 1: Start the process
Step 2: Accept the number of processes in the ready Queue
Step 3: For each process in the ready Q, assign the process id and accept the CPU burst time
Step 4: Set the waiting of the first process as ‘0’ and its burst time as its turn around time 
Step 5: for each process in the Ready Q calculate
(a)	Waiting time for process(n)= waiting time of process (n-1) + Burst time of process(n-1)
(b)	Turnaround time for Process(n)= waiting time of Process(n)+ Burst time for process(n)
Step 6: Calculate 
(a)	Average waiting time = Total waiting Time / Number of process
(b)	Average Turnaround time = Total Turnaround Time / Number of process
Step 7: Stop the process
Expected output:
Enter number of processors: 3
Enter the Burst Time of the process 1:   2
Enter the Burst Time of the process 2:    5
Enter the Burst Time of the process 3:    4
FIRST COME FIRST SERVE SCHEDULING ALGORITHM
Process ID      Waiting Time    Turn Around Time
1                0                           2
 	2               2                            7
              3               7                           11
Average Waiting Time 3.00
Average Turnaround Time 6.67
Source code:
#include<stdio.h>
void main()
{
 int i,n,sum,wt,tat,twt,ttat;
 int t[10];
 float awt,atat;
 clrscr();
 printf("Enter number of processors:\n");
 scanf("%d",&n);
 for(i=0;i<n;i++)
 {
   printf("\n Enter the Burst Time of the process %d",i+1);
   scanf("\n %d",&t[i]);
 }
 printf("\n\n FIRST COME FIRST SERVE SCHEDULING ALGORITHM \n");
 printf("\n Process ID \t Waiting Time \t Turn Around Time \n");
 printf("1 \t\t 0 \t\t %d \n",t[0]);
 sum=0;
 twt=0;
 ttat=t[0];
 for(i=1;i<n;i++)
 {
  sum+=t[i-1];
  wt=sum;
  tat=sum+t[i];
  twt=twt+wt;
  ttat=ttat+tat;
  printf("\n %d \t\t %d \t\t %d",i+1,wt,tat);
  printf("\n\n");
 }
  awt=(float)twt/n;
  atat=(float)ttat/n;
  printf("\n Average Waiting Time %4.2f",awt);
  printf("\n Average Turnaround Time %4.2f",atat);
  getch();
}

Actual output:
Enter number of processors: 3
Enter the Burst Time of the process 1:   2
Enter the Burst Time of the process 2:    5
Enter the Burst Time of the process 3:    4
FIRST COME FIRST SERVE SCHEDULING ALGORITHM
Process ID      Waiting Time    Turn Around Time
1                0                           2
 	2               2                            7
              3               7                           11
Average Waiting Time 3.00
Average Turnaround Time 6.67








Aim:  (B.) Write a C program to implement SJF scheduling mechanisms  
Algorithm:
Step 1: Start the process
Step 2: Accept the number of processes in the ready Queue
Step 3: For each process in the ready Q, assign the process id and accept the CPU burst time
Step 4: Start the Ready Q according the shortest Burst time by sorting according to lowest to
 highest burst time.
Step 5: Set the waiting time of the first process as ‘0’ and its turnaround time as its burst time.
Step 6: For each process in the ready queue, calculate  
(c)	Waiting time for process(n)= waiting time of process (n-1) + Burst time of process(n-1)
(d)	Turn around time for Process(n)= waiting time of Process(n)+ Burst time for process(n)
Step 6: Calculate 
(c)	Average waiting time = Total waiting Time / Number of process
(d)	Average Turnaround time = Total Turnaround Time / Number of process
Step 7: Stop the process
Expected output:
Enter number of process: 3
Enter the Burst Time of Process 04
Enter the Burst Time of Process 13
Enter the Burst Time of Process 25
 SHORTEST JOB FIRST SCHEDULING ALGORITHM
 PROCESS ID      BURST TIME      WAITING TIME    TURNAROUND TIME
    1           3                    0               3
    0           4                    3               7
    2           5                    7              12
 AVERAGE WAITING TIME 3.33
 AVERAGE TURN AROUND TIME 7.33
Source code:
#include<stdio.h>
void main()
{
 int i,j,k,n,sum,wt[10],tt[10],twt,ttat;
 int t[10],p[10];
 float awt,atat;
 clrscr();
 printf("Enter number of process\n");
 scanf("%d",&n);
 for(i=0;i<n;i++)
 {
    printf("\n Enter the Burst Time of Process %d",i);
    scanf("\n %d",&t[i]);
 }
 for(i=0;i<n;i++)
   p[i]=i;
   for(i=0;i<n;i++)
   {
     for(k=i+1;k<n;k++)
     {
       if(t[i]>t[k])
       {
	  int temp;
	  temp=t[i];
	  t[i]=t[k];
	  t[k]=temp;
	  temp=p[i];
	  p[i]=p[k];
	  p[k]=temp;
       }
     }
     printf("\n\n SHORTEST JOB FIRST SCHEDULING ALGORITHM");
     printf("\n PROCESS ID \t BURST TIME \t WAITING TIME \t TURNAROUND TIME \n\n");
     wt[0]=0;
     for(i=0;i<n;i++)
     {
       sum=0;
       for(k=0;k<i;k++)
       {
	wt[i]=sum+t[k];
	sum=wt[i];
       }
     }
     for(i=0;i<n;i++)
     {
       tt[i]=t[i]+wt[i];
     }
     for(i=0;i<n;i++)
     {
       printf("%5d \t\t5%d \t\t %5d \t\t %5d \n\n",p[i],t[i],wt[i],tt[i]);
     }
     twt=0;
     ttat=t[0];
     for(i=1;i<n;i++)
     {
	twt=twt+wt[i];
	ttat=ttat+tt[i];
     }
     awt=(float)twt/n;
     atat=(float)ttat/n;
     printf("\n AVERAGE WAITING TIME %4.2f",awt);
     printf("\n AVERAGE TURN AROUND TIME %4.2f",atat);
     getch();
   }
}



Actual output:
Enter number of process: 3
Enter the Burst Time of Process 04
Enter the Burst Time of Process 13
Enter the Burst Time of Process 25
 SHORTEST JOB FIRST SCHEDULING ALGORITHM
 PROCESS ID      BURST TIME      WAITING TIME    TURNAROUND TIME
    1           3                    0               3
    0           4                    3               7
    2           5                    7              12
 AVERAGE WAITING TIME 3.33
 AVERAGE TURN AROUND TIME 7.33





Aim:  (C.) Write a C program to implement priority scheduling mechanisms  
Algorithm:
Step 1: Start the process
Step 2: Accept the number of processes in the ready Queue
Step 3: For each process in the ready Q, assign the process id and accept the CPU burst time
Step 4: Sort the ready queue according to the priority number.
Step 5: Set the waiting of the first process as ‘0’ and its burst time as its turn around time 
Step 6: For each process in the Ready Q calculate
(e)	Waiting time for process(n)= waiting time of process (n-1) + Burst time of process(n-1)
(f)	Turn around time for Process(n)= waiting time of Process(n)+ Burst time for process(n)
Step 7: Calculate 
(e)	Average waiting time = Total waiting Time / Number of process
(f)	Average Turnaround time = Total Turnaround Time / Number of process
Step 8: Stop the process













Expected output:
-----------PRIORITY SCHEDULING--------------
Enter the No of Process:         4
Enter the Burst time of Pid 0 : 2
Enter the Priority   of Pid 0 :    3
Enter the Burst time of Pid 1 : 6
Enter the Priority   of Pid 1 :    2
Enter the Burst time of Pid 2 : 4
Enter the Priority   of Pid 2 :    1
Enter the Burst time of Pid 3 : 5
Enter the Priority   of Pid 3 :    7
----------------------------------------------------------------------------------------
Pid      Priority       Burst time       WaitingTime    TurnArroundTime
----------------------------------------------------------------------------------------
2               1      	 4                        0                       4
1               2     	 6                        4                      10
0               3      	 2                       10                     12
3               7       	 5                       12                      17
Avg.Waiting Time: 6.500000
Avg.Turn Around Time: 10.750000









Source code:
#include <stdio.h>
#include <conio.h>
void main()
{
	int i,j,n,tat[10],wt[10],bt[10],pid[10],pr[10],t,twt=0,ttat=0;
	float awt,atat;
	clrscr();
	printf("\n-----------PRIORITY SCHEDULING--------------\n");
	printf("Enter the No of Process: ");
	scanf("%d", &n);
	for (i=0;i<n;i++)
		{
			pid[i] = i;
			printf("Enter the Burst time of Pid %d : ",i);
			scanf("%d",&bt[i]);
			printf("Enter the Priority   of Pid %d : ",i);
			scanf ("%d",&pr[i]);
		}
// Sorting start
		for (i=0;i<n;i++)
			for(j=i+1;j<n;j++)
			{
				if (pr[i] > pr[j] )
				{
					t = pr[i];
					pr[i] = pr[j];
					pr[j] = t;

					t = bt[i];
					bt[i] = bt[j];
					bt[j] = t;
					t = pid[i];
					pid[i] = pid[j];
					pid[j] = t;
				}
			}
// Sorting finished
	tat[0] = bt[0];
	wt[0] = 0;
	for (i=1;i<n;i++)
		{
		wt[i] = wt[i-1] + bt[i-1];
		tat[i] = wt[i] + bt[i];
		}
  	printf("\n---------------------------------------------------------------\n");
	printf("Pid\t Priority\tBurst time\t WaitingTime\tTurnArroundTime\n");
	printf("\n--------------------------------------------------------------\n");
		for(i=0;i<n;i++)
		{
			printf("\n%d\t\t%d\t%d\t\t%d\t\t%d",pid[i],pr[i],bt[i],wt[i],tat[i]);
		}
	for(i=0;i<n;i++)
		{
		ttat = ttat+tat[i];
		twt = twt + wt[i];
		}
	awt = (float)twt / n;
	atat = (float)ttat / n;
	printf("\n\nAvg.Waiting Time: %f\nAvg.Turn Around Time: %f\n",awt,atat);
	getch();
}


Actual output:
-----------PRIORITY SCHEDULING--------------
Enter the No of Process:         4
Enter the Burst time of Pid 0 : 2
Enter the Priority   of Pid 0 :    3
Enter the Burst time of Pid 1 : 6
Enter the Priority   of Pid 1 :    2
Enter the Burst time of Pid 2 : 4
Enter the Priority   of Pid 2 :    1
Enter the Burst time of Pid 3 : 5
Enter the Priority   of Pid 3 :    7
----------------------------------------------------------------------------------------
Pid      Priority       Burst time       WaitingTime    TurnArroundTime
----------------------------------------------------------------------------------------
2               1      	 4                        0                       4
1               2     	 6                        4                      10
0               3      	 2                       10                     12
3               7       	 5                       12                      17
Avg.Waiting Time: 6.500000
Avg.Turn Around Time: 10.750000



Aim:  (D.) Write a C program to implement round robin scheduling mechanisms 
Algorithm: 
Step 1: Start the process
Step 2: Accept the number of processes in the ready Queue and time quantum (or) time slice
Step 3: For each process in the ready Q, assign the process id and accept the CPU burst time
Step 4: Calculate the no. of time slices for each process where
	No. of time slice for process(n) = burst time process(n)/time  slice
Step 5: If the burst time is less than the time slice then the no. of time slices =1.
Step 6: Consider the ready queue is a circular Q, calculate
(a)	Waiting time for process(n) = waiting time of process(n-1)+ burst time of process(n-1 ) + the time difference in getting the CPU from process(n-1)
(b)	Turn around time for process(n) = waiting time of process(n) + burst time of process(n)+ the time difference in getting CPU from process(n).
Step 7: Calculate 
(g)	Average waiting time = Total waiting Time / Number of process
(h)	Average Turnaround time = Total Turnaround Time / Number of process
Step 8: Stop the process










Expected output:
          ROUND ROBIN SCHEDULING
Enter the number of Processors: 4
Enter the Timeslice: 5
Enter the process ID 1  5
Enter the Burst Time for the process 10
Enter the process ID 2   6
Enter the Burst Time for the process 15
Enter the process ID 3   7
Enter the Burst Time for the process 20
Enter the process ID 4   8
Enter the Burst Time for the process 25
 ROUND ROBIN SCHEDULING ALGORITHM
 Process         Process ID      BurstTime       Waiting Time    TurnaroundTime
     1       	5             	 10              	15              	25
     2       	6              	15             	 25              	40
     3       	7              	20              	25              	45
     4      	 8             	 25              	20             	 45
 The average Waiting Time=4.2f
 The average Turn around Time=4.2f









Source code:
#include<stdio.h>
#include<conio.h>
void main()
{
 int ts,pid[10],need[10],wt[10],tat[10],i,j,n,n1;
 int bt[10],flag[10],ttat=0,twt=0;
 float awt,atat;
 clrscr();
 printf("\t\t ROUND ROBIN SCHEDULING \n");
 printf("Enter the number of Processors \n");
 scanf("%d",&n);
 n1=n;
 printf("\n Enter the Timeslice \n");
 scanf("%d",&ts);
 for(i=1;i<=n;i++)
 {
   printf("\n Enter the process ID %d",i);
   scanf("%d",&pid[i]);
   printf("\n Enter the Burst Time for the process");
   scanf("%d",&bt[i]);
   need[i]=bt[i];
 }
 for(i=1;i<=n;i++)
 {
  flag[i]=1;
  wt[i]=0;
 }

 while(n!=0)
 {
   for(i=1;i<=n;i++)
   {
     if(need[i]>=ts)
     {
       for(j=1;j<=n;j++)
       {
	  if((i!=j)&&(flag[i]==1)&&(need[j]!=0))
	  wt[j]+=ts;
       }
       need[i]-=ts;
       if(need[i]==0)
       {
	 flag[i]=0;
	 n--;
       }
     }
     else
     {
       for(j=1;j<=n;j++)
       {
	  if((i!=j)&&(flag[i]==1)&&(need[j]!=0))
	  wt[j]+=need[i];
       }
       need[i]=0;
       n--;
       flag[i]=0;
   }
 }
}
for(i=1;i<=n1;i++)
{
  tat[i]=wt[i]+bt[i];
  twt=twt+wt[i];
  ttat=ttat+tat[i];
}
awt=(float)twt/n1;
atat=(float)ttat/n1;
printf("\n\n ROUND ROBIN SCHEDULING ALGORITHM \n\n");
printf("\n\n Process \t Process ID  \t BurstTime \t Waiting Time \t TurnaroundTime \n ");
for(i=1;i<=n1;i++)
{
  printf("\n %5d \t %5d \t\t %5d \t\t %5d \t\t %5d \n", i,pid[i],bt[i],wt[i],tat[i]);
}
printf("\n The average Waiting Time=4.2f",awt);
printf("\n The average Turn around Time=4.2f",atat);
getch();
}         
         








Actual output:
          ROUND ROBIN SCHEDULING
Enter the number of Processors: 4
Enter the Timeslice: 5
Enter the process ID 1  5
Enter the Burst Time for the process 10
Enter the process ID 2   6
Enter the Burst Time for the process 15
Enter the process ID 3   7
Enter the Burst Time for the process 20
Enter the process ID 4   8
Enter the Burst Time for the process 25
 ROUND ROBIN SCHEDULING ALGORITHM
 Process         Process ID      BurstTime       Waiting Time    TurnaroundTime
     1       	5             	 10              	15              	25
     2       	6              	15             	 25              	40
     3       	7              	20              	25              	45
     4      	 8             	 25              	20             	 45
 The average Waiting Time=4.2f
 The average Turn around Time=4.2f









Experiment 3:
Simulate The Following
Aim: (A.) Multiprogramming with A Fixed Number Of Tasks (MFT)
Algorithm:
Step1: start the process.
Step2: Declare variables.
Step3: Enter total memory size.
Step4: Allocate memory for os.
Step5: allocate total memory to the pages.
Step6: Display the wastage of memory.
Step7: Stop the process. 

Expected output:
Enter total memory size : 50
Enter memory for OS    :10
Enter no.of partitions to be divided:4
Enter size of page  : 10
Enter size of page  : 9
Enter size of page  : 9
Enter size of page  : 8

Internal Fragmentation is = 4







Source code:
#include<stdio.h>
#include<conio.h>
main()
{
	int ms,i,ps[20],n,size,p[20],s,intr=0;
	clrscr();
	printf("Enter size of memory:");
	scanf("%d",&ms);
	printf("Enter memory for OS:");
	scanf("%d",&s);
	ms-=s;
	printf("Enter no.of partitions to be divided:");
	scanf("%d",&n);
	size=ms/n;
	for(i=0;i<n;i++)
	{
		printf("Enter process and process size");
		scanf("%d%d",&p[i],&ps[i]);
		if(ps[i]<=size)
		{
			intr=intr+size-ps[i];
			printf("process%d is allocated\n",p[i]);
		}
		else
			printf("process%d is blocked",p[i]);
	}
	printf("total fragmentation is %d",intr);
	getch();}
Actual output:
Enter total memory size : 50
Enter memory for OS    :10
Enter no.of partitions to be divided:4
Enter size of page  : 10
Enter size of page  : 9
Enter size of page  : 9
Enter size of page  : 8

Internal Fragmentation is = 4



















Aim: (B.) Multiprogramming with A Fixed Number Of Tasks (MVT)
Algorithm:
Step1: start the process.
Step2: Declare variables.
Step3: Enter total memory size.
Step4: Allocate memory for os.
Step5: allocate total memory to the pages.
Step6: Display the wastage of memory.
Step7: Stop the process. 


Expected output:
Enter total memory size : 50
Enter no.of pages          : 4
Enter memory for OS    :10
Enter size of page  : 10
Enter size of page  : 9
Enter size of page  : 9
Enter size of page  : 10

External Fragmentation is = 2








Source code:
#include<stdio.h>
#include<conio.h>
main()
{
	int i,m,n,tot,s[20];
	clrscr();
	printf("Enter total memory size:");
	scanf("%d",&tot);
	printf("Enter no. of pages:");
	scanf("%d",&n);
	printf("Enter memory for OS:");
	scanf("%d",&m);
	for(i=0;i<n;i++)
	{
		printf("Enter size of page%d:",i+1);
		scanf("%d",&s[i]);
	}
	tot=tot-m;
	for(i=0;i<n;i++)
	{
		if(tot>=s[i])
		{
			printf("Allocate page %d\n",i+1);
			tot=tot-s[i];
		}
		else
			printf("process p%d is blocked\n",i+1);
	}
	printf("External Fragmentation is=%d",tot);
	getch();
}


Actual output:
Enter total memory size : 50
Enter no.of pages          : 4
Enter memory for OS    :10
Enter size of page  : 10
Enter size of page  : 9
Enter size of page  : 9
Enter size of page  : 10

External Fragmentation is = 2














Experiment 4:
Aim: Simulate Bankers Algorithm for Dead Lock Avoidance
Algorithm:
Step 1: Start the program.
Step 2: Get the values of resources and processes.
Step 3: Get the avail value.
Step 4: After allocation find the need value.
Step 5: Check whether its possible to allocate.
Step 6: If it is possible then the system is in safe state.
Step 7: Else system is not in safety state.
Step 8: If the new request comes then check that the system is in safety.
Step 9: or not if we allow the request.
Step 10: stop the program.

Expected output:
//TEST CASE 1:
 ENTER THE NO. OF PROCESSES:4
 ENTER THE NO. OF RESOURCES:3
PROCESS 1
MAXIMUM VALUE FOR RESOURCE 1:3
MAXIMUM VALUE FOR RESOURCE 2:2
MAXIMUM VALUE FOR RESOURCE 3:2
ALLOCATED FROM RESOURCE 1:1
ALLOCATED FROM RESOURCE 2:0
ALLOCATED FROM RESOURCE 3:0
PROCESS 2
MAXIMUM VALUE FOR RESOURCE 1:6
MAXIMUM VALUE FOR RESOURCE 2:1
MAXIMUM VALUE FOR RESOURCE 3:3
ALLOCATED FROM RESOURCE 1:5
ALLOCATED FROM RESOURCE 2:1
ALLOCATED FROM RESOURCE 3:1
PROCESS 3
MAXIMUM VALUE FOR RESOURCE 1:3
MAXIMUM VALUE FOR RESOURCE 2:1
MAXIMUM VALUE FOR RESOURCE 3:4
ALLOCATED FROM RESOURCE 1:2
ALLOCATED FROM RESOURCE 2:1
ALLOCATED FROM RESOURCE 3:1
PROCESS 4
MAXIMUM VALUE FOR RESOURCE 1:4
MAXIMUM VALUE FOR RESOURCE 2:2
MAXIMUM VALUE FOR RESOURCE 3:2
ALLOCATED FROM RESOURCE 1:0
ALLOCATED FROM RESOURCE 2:0
ALLOCATED FROM RESOURCE 3:2
ENTER TOTAL VALUE OF RESOURCE 1:9
ENTER TOTAL VALUE OF RESOURCE 2:3
ENTER TOTAL VALUE OF RESOURCE 3:6

 RESOURCES   ALLOCATED   NEEDED          TOTAL   AVAIL
 P1       322          100        222                                936    112
 P2       613          511        102
 P3       314          211        103
 P4       422          002        420

	 AVAIL BEFORE AVAIL AFTER
 P 2             010     623
 P 1             401     723
 P 3             620     934
 P 4             514     936

THE ABOVE SEQUENCE IS A SAFE SEQUENCE
Source code:
#include<stdio.h>
#include<conio.h>
struct da
{
    int max[10],a1[10],need[10],before[10],after[10];
 }p[10];
 void main()
 {
  int i,j,k,l,r,n,tot[10],av[10],cn=0,cz=0,temp=0,c=0;
 clrscr();
 printf("\n ENTER THE NO. OF PROCESSES:");
 scanf("%d",&n);
 printf("\n ENTER THE NO. OF RESOURCES:");
 scanf("%d",&r);
 for(i=0;i<n;i++)
 {
    printf("PROCESS %d \n",i+1);
    for(j=0;j<r;j++)
    {
     printf("MAXIMUM VALUE FOR RESOURCE %d:",j+1);
     scanf("%d",&p[i].max[j]);
    }
   for(j=0;j<r;j++)
    {
     printf("ALLOCATED FROM RESOURCE %d:",j+1);
     scanf("%d",&p[i].a1[j]);
     p[i].need[j]=p[i].max[j]-p[i].a1[j];
    }
 }
	for(i=0;i<r;i++)
	{
	  printf("ENTER TOTAL VALUE OF RESOURCE %d:",i+1);
	  scanf("%d",&tot[i]);
	}
	for(i=0;i<r;i++)
	{
	  for(j=0;j<n;j++)
	  temp=temp+p[j].a1[i];
	  av[i]=tot[i]-temp;
	  temp=0;
	}
  printf("\n\t RESOURCES  ALLOCATED   NEEDED   TOTAL  AVAIL");
  for(i=0;i<n;i++)
  {
    printf("\n P%d \t",i+1);
    for(j=0;j<r;j++)
    printf("%d",p[i].max[j]);
    printf("\t");
    for(j=0;j<r;j++)
    printf("%d",p[i].a1[j]);
    printf("\t");
    for(j=0;j<r;j++)
    printf("%d",p[i].need[j]);
    printf("\t");
    for(j=0;j<r;j++)
    {
	  if(i==0)
	  printf("%d",tot[j]);
    }
    printf("    ");
    for(j=0;j<r;j++)
   {
       if(i==0)
       printf("%d",av[j]);
   }
 }
   printf("\n\n\t AVAIL  BEFORE\T AVAIL AFTER ");
   for(l=0;l<n;l++)
   {
    for(i=0;i<n;i++)
    {
	 for(j=0;j<r;j++)
	 {
	   if(p[i].need[j] >av[j])
	   cn++;
	   if(p[i].max[j]==0)
	   cz++;
	 }
    if(cn==0 && cz!=r)
    {
      for(j=0;j<r;j++)
      {
	p[i].before[j]=av[j]-p[i].need[j];
	p[i].after[j]=p[i].before[j]+p[i].max[j];
	av[j]=p[i].after[j];
	p[i].max[j]=0;
      }
      printf("\n P %d \t",i+1);
       for(j=0;j<r;j++)
       printf("%d",p[i].before[j]);
       printf("\t");
       for(j=0;j<r;j++)
       printf("%d",p[i].after[j]);
	 cn=0;
	 cz=0;
	 c++;
	 break;
   }
   else
   {
     cn=0;cz=0;
   }
  }
}
 if(c==n)
 printf("\n THE ABOVE SEQUENCE IS A SAFE SEQUENCE");
    else
    printf("\n DEADLOCK OCCURED");
    getch();
}





Actual output:
//TEST CASE 1:
 ENTER THE NO. OF PROCESSES:4
 ENTER THE NO. OF RESOURCES:3
PROCESS 1
MAXIMUM VALUE FOR RESOURCE 1:3
MAXIMUM VALUE FOR RESOURCE 2:2
MAXIMUM VALUE FOR RESOURCE 3:2
ALLOCATED FROM RESOURCE 1:1
ALLOCATED FROM RESOURCE 2:0
ALLOCATED FROM RESOURCE 3:0
PROCESS 2
MAXIMUM VALUE FOR RESOURCE 1:6
MAXIMUM VALUE FOR RESOURCE 2:1
MAXIMUM VALUE FOR RESOURCE 3:3
ALLOCATED FROM RESOURCE 1:5
ALLOCATED FROM RESOURCE 2:1
ALLOCATED FROM RESOURCE 3:1
PROCESS 3
MAXIMUM VALUE FOR RESOURCE 1:3
MAXIMUM VALUE FOR RESOURCE 2:1
MAXIMUM VALUE FOR RESOURCE 3:4
ALLOCATED FROM RESOURCE 1:2
ALLOCATED FROM RESOURCE 2:1
ALLOCATED FROM RESOURCE 3:1
PROCESS 4
MAXIMUM VALUE FOR RESOURCE 1:4
MAXIMUM VALUE FOR RESOURCE 2:2
MAXIMUM VALUE FOR RESOURCE 3:2
ALLOCATED FROM RESOURCE 1:0
ALLOCATED FROM RESOURCE 2:0
ALLOCATED FROM RESOURCE 3:2
ENTER TOTAL VALUE OF RESOURCE 1:9
ENTER TOTAL VALUE OF RESOURCE 2:3
ENTER TOTAL VALUE OF RESOURCE 3:6

 RESOURCES   ALLOCATED   NEEDED          TOTAL   AVAIL
 P1       322          100        222                                936    112
 P2       613          511        102
 P3       314          211        103
 P4       422          002        420

	 AVAIL BEFORE AVAIL AFTER
 P 2             010     623
 P 1             401     723
 P 3             620     934
 P 4             514     936

THE ABOVE SEQUENCE IS A SAFE SEQUENCE









Experiment 5:
Aim: Simulate Bankers Algorithm for Dead Lock Prevention.
Algorithm:
Step 1: Start the program.
Step 2: Get the values of resources and processes.
Step 3: Get the avail value.
Step 4: After allocation find the need value.
Step 5: Check whether its possible to allocate.
Step 6: If it is possible then the system is in safe state.
Step 7: Else system is not in safety state.
Step 8: If the new request comes then check that the system is in safety.
Step 9: or not if we allow the request.
Step 10: stop the program.
 
Expected output:
Enter number of process:5
Enter number of resources:3
Enter total numbers of each resources:10 5 7

Enter Max resources for each process:
for process 1:7 5 3
for process 2:3 2 2
for process 3:9 0 2
for process 4:2 2 2
for process 5:4 3 3

Enter allocated resources for each process:
for process 1:0 1 0
for process 2:3 0 2
for process 3:3 0 2
for process 4:2 1 1
for process 5:0 0 2

available resources:
     2       3       0
 Allocated matrix             Max         need
        0   1   0                |   7   5   3 |   7   4   3
        3   0   2                |   3   2   2 |   0   2   0
        3   0   2                |   9   0   2 |   6   0   0
        2   1   1                |   2   2   2 |   0   1   1
        0   0   2                |   4   3   3 |   4   3   1
 Process 2 completed
 Available matrix:   5   3   2
 Allocated matrix        Max          need
        0   1   0           |   7   5   3 |   7   4   3
        0   0   0           |   0   0   0 |   0   0   0
        3   0   2           |   9   0   2 |   6   0   0
        2   1   1           |   2   2   2 |   0   1   1
        0   0   2           |   4   3   3 |   4   3   1
 Process 4 completed
 Available matrix:   7   4   3
 Allocated matrix        Max      need
   0   1   0                |   7   5   3|   7   4   3
   0   0   0                |   0   0   0|   0   0   0
   3   0   2                |   9   0   2|   6   0   0
   0   0   0                |   0   0   0|   0   0   0
   0   0   2                |   4   3   3|   4   3   1
 Process 1 completed
 Available matrix:   7   5   3
 Allocated matrix        Max      need
   0   0   0                |   0   0   0|   0   0   0
   0   0   0                |   0   0   0|   0   0   0
   3   0   2                |   9   0   2|   6   0   0
   0   0   0                |   0   0   0|   0   0   0
   0   0   2                |   4   3   3|   4   3   1
 Process 3 completed
 Available matrix:   10   5   5
 Allocated matrix        Max      need
   0   0   0                |   0   0   0|   0   0   0
   0   0   0                |   0   0   0|   0   0   0
   0   0   0                |   0   0   0|   0   0   0
   0   0   0                |   0   0   0|   0   0   0
   0   0   2                |   4   3   3|   4   3   1
 Process 5 completed
 Available matrix:   10   5   7
The system is in a safe state!!















Source code:

#include< stdio.h>
#include< conio.h>
void main()
{
 int allocated[15][15],max[15][15],need[15][15],avail[15],tres[15],work[15],flag[15];
 int pno,rno,i,j,prc,count,t,total;
 count=0;
 clrscr();
 printf("\n Enter number of process:");
 scanf("%d",&pno);
 printf("\n Enter number of resources:");
 scanf("%d",&rno);
 for(i=1;i< =pno;i++)
 {
  flag[i]=0;
 }
 printf("\n Enter total numbers of each resources:");
 for(i=1;i<= rno;i++)
  scanf("%d",&tres[i]);
 printf("\n Enter Max resources for each process:");
 for(i=1;i<= pno;i++)
 {
  printf("\n for process %d:",i);
  for(j=1;j<= rno;j++)
   scanf("%d",&max[i][j]);
 }
 printf("\n Enter allocated resources for each process:");
 for(i=1;i<= pno;i++)
 {
  printf("\n for process %d:",i);
  for(j=1;j<= rno;j++)
   scanf("%d",&allocated[i][j]);
 }
 printf("\n available resources:\n");
 for(j=1;j<= rno;j++)
 {
  avail[j]=0;
  total=0;
  for(i=1;i<= pno;i++)
  {
   total+=allocated[i][j];
  }
  avail[j]=tres[j]-total;
  work[j]=avail[j];
  printf("     %d \t",work[j]);
 }


 do
 {
 for(i=1;i<= pno;i++)
 {
  for(j=1;j<= rno;j++)
  {
   need[i][j]=max[i][j]-allocated[i][j];
  }
 }
 printf("\n Allocated matrix        Max      need");
 for(i=1;i<= pno;i++)
 {
  printf("\n");
  for(j=1;j<= rno;j++)
  {
   printf("%4d",allocated[i][j]);
  }
  printf("|");
  for(j=1;j<= rno;j++)
  {
   printf("%4d",max[i][j]);
  }
   printf("|");
  for(j=1;j<= rno;j++)
  {
   printf("%4d",need[i][j]);
  }
 }
  prc=0;

  for(i=1;i<= pno;i++)
  {
   if(flag[i]==0)
   {
    prc=i;
    for(j=1;j<= rno;j++)
    {
     if(work[j]< need[i][j])
     {
       prc=0;
       break;
     }
    }
   }


   if(prc!=0)
   break;
  }
  if(prc!=0)
  {
   printf("\n Process %d completed",i);
   count++;
   printf("\n Available matrix:");
   for(j=1;j<= rno;j++)
   {
    work[j]+=allocated[prc][j];
    allocated[prc][j]=0;
    max[prc][j]=0;
    flag[prc]=1;
    printf("   %d",work[j]);
   }
  }
 }
while(count!=pno&&prc!=0);
 if(count==pno)
  printf("\nThe system is in a safe state!!");
 else
  printf("\nThe system is in an unsafe state!!");
 getch();
}

Actual output:

Enter number of process:5
Enter number of resources:3
Enter total numbers of each resources:10 5 7

Enter Max resources for each process:
for process 1:7 5 3
for process 2:3 2 2
for process 3:9 0 2
for process 4:2 2 2
for process 5:4 3 3

Enter allocated resources for each process:
for process 1:0 1 0
for process 2:3 0 2
for process 3:3 0 2
for process 4:2 1 1
for process 5:0 0 2

available resources:
     2       3       0
 Allocated matrix             Max         need
        0   1   0                |   7   5   3 |   7   4   3
        3   0   2                |   3   2   2 |   0   2   0
        3   0   2                |   9   0   2 |   6   0   0
        2   1   1                |   2   2   2 |   0   1   1
        0   0   2                |   4   3   3 |   4   3   1
 Process 2 completed
 Available matrix:   5   3   2
 Allocated matrix        Max          need
        0   1   0           |   7   5   3 |   7   4   3
        0   0   0           |   0   0   0 |   0   0   0
        3   0   2           |   9   0   2 |   6   0   0
        2   1   1           |   2   2   2 |   0   1   1
        0   0   2           |   4   3   3 |   4   3   1
 Process 4 completed
 Available matrix:   7   4   3
 Allocated matrix        Max      need
   0   1   0                |   7   5   3|   7   4   3
   0   0   0                |   0   0   0|   0   0   0
   3   0   2                |   9   0   2|   6   0   0
   0   0   0                |   0   0   0|   0   0   0
   0   0   2                |   4   3   3|   4   3   1
 Process 1 completed
 Available matrix:   7   5   3
 Allocated matrix        Max      need
   0   0   0                |   0   0   0|   0   0   0
   0   0   0                |   0   0   0|   0   0   0
   3   0   2                |   9   0   2|   6   0   0
   0   0   0                |   0   0   0|   0   0   0
   0   0   2                |   4   3   3|   4   3   1
 Process 3 completed
 Available matrix:   10   5   5
 Allocated matrix        Max      need
   0   0   0                |   0   0   0|   0   0   0
   0   0   0                |   0   0   0|   0   0   0
   0   0   0                |   0   0   0|   0   0   0
   0   0   0                |   0   0   0|   0   0   0
   0   0   2                |   4   3   3|   4   3   1
 Process 5 completed
 Available matrix:   10   5   7
The system is in a safe state!!




Experiment 6:
Simulate the Following Page Replacement Algorithms.
Aim: (A.) Simulate the FIFO Page Replacement Algorithm
Algorithm: 
Step 1:  Create a queue to hold all pages in memory
Step 2:  When the page is required replace the page at the head of the queue
Step 3:  Now the new page is inserted at the tail of the queue

Expected output:
                         FIFO PAGE REPLACEMENT ALGORITHM
Enter no.of frames....4
Enter number of reference string.. 6
Enter the reference string.. 5 6 4 1 2 3
The given reference string:       ......................................   5   6   4   1   2   3
         Reference np5->           5  -1  -1  -1
         Reference np6->           5   6  -1  -1
         Reference np4->           5   6   4  -1
         Reference np1->           5   6   4   1
         Reference np2->           2   6   4   1
         Reference np3->           2   3   4   1
                         No.of pages faults...6








Source code:
#include<stdio.h>
#include<conio.h>
int i,j,nof,nor,flag=0,ref[50],frm[50],pf=0,victim=-1;
void main()
{
 clrscr();
 printf("\n \t\t\t FIFI PAGE REPLACEMENT ALGORITHM");
 printf("\n Enter no.of frames....");
 scanf("%d",&nof);
 printf("Enter number of reference string..\n");
 scanf("%d",&nor);
 printf("\n Enter the reference string..");
 for(i=0;i<nor;i++)
 scanf("%d",&ref[i]);
 printf("\nThe given reference string:");
 for(i=0;i<nor;i++)
 printf("%4d",ref[i]);
 for(i=1;i<=nof;i++)
 frm[i]=-1;
 printf("\n");
 for(i=0;i<nor;i++)
 {
   flag=0;
   printf("\n\t Reference np%d->\t",ref[i]);
   for(j=0;j<nof;j++)
   {
     if(frm[j]==ref[i])
     {
       flag=1;
       break;
     }}
      if(flag==0)
   {
     pf++;
     victim++;
     victim=victim%nof;
     frm[victim]=ref[i];
     for(j=0;j<nof;j++)
     printf("%4d",frm[j]);
   }
 }
 printf("\n\n\t\t No.of pages faults...%d",pf);
 getch();
}
Actual output:
                         FIFO PAGE REPLACEMENT ALGORITHM
Enter no.of frames....4
Enter number of reference string.. 6
Enter the reference string.. 5 6 4 1 2 3
The given reference string:       ......................................   5   6   4   1   2   3
         Reference np5->           5  -1  -1  -1
         Reference np6->           5   6  -1  -1
         Reference np4->           5   6   4  -1
         Reference np1->           5   6   4   1
         Reference np2->           2   6   4   1
         Reference np3->           2   3   4   1
                         No.of pages faults...6
Aim: (B.) Simulate the LRU Page Replacement Algorithm
Algorithm: 
Step 1:  Create a queue to hold all pages in memory
Step 2:  When the page is required replace the page at the head of the queue
Step 3:  Now the new page is inserted at the tail of the queue
Step 4:  Create a stack
Step 5:  When the page fault occurs replace page present at the bottom of the stack

Expected output:
                         
                       LRU PAGE REPLACEMENT ALGORITHM
Enter no.of Frames....3
Enter no.of reference string..6
Enter reference string..6 5 4 2 3 1
                 LRU PAGE REPLACEMENT ALGORITHM 
The given reference string:          ………………….  6   5   4   2   3   1
         Reference NO 6->          6  -1  -1
         Reference NO 5->          6   5  -1
         Reference NO 4->          6   5   4
         Reference NO 2->          2   5   4
         Reference NO 3->          2   3   4
         Reference NO 1->          2   3   1
         No.of page faults...6




Source code:
#include<stdio.h>
#include<conio.h>
int i,j,nof,nor,flag=0,ref[50],frm[50],pf=0,victim=-1;
int recent[10],lrucal[50],count=0;
int lruvictim();
void main()
{
  clrscr();
  printf("\n\t\t\t LRU PAGE REPLACEMENT ALGORITHM");
  printf("\n Enter no.of Frames....");
  scanf("%d",&nof);
  printf(" Enter no.of reference string..");
  scanf("%d",&nor);
  printf("\n Enter reference string..");
  for(i=0;i<nor;i++)
  scanf("%d",&ref[i]);
  printf("\n\n\t\t LRU PAGE REPLACEMENT ALGORITHM ");
  printf("\n\t The given reference string:");
  printf("\n………………………………..");
  for(i=0;i<nor;i++)
  printf("%4d",ref[i]);
  for(i=1;i<=nof;i++)
  {
    frm[i]=-1;
    lrucal[i]=0;
  }
  for(i=0;i<10;i++)
   recent[i]=0;
   printf("\n");
   for(i=0;i<nor;i++)
   {
     flag=0;
     printf("\n\t Reference NO %d->\t",ref[i]);
     for(j=0;j<nof;j++)
     {
               if(frm[j]==ref[i])
       {
	 flag=1;
	 break;
       }
     }

     if(flag==0)
     {
       count++;
       if(count<=nof)
       victim++;
       else
       victim=lruvictim();
       pf++;
       frm[victim]=ref[i];
       for(j=0;j<nof;j++)
       printf("%4d",frm[j]);
     }
     recent[ref[i]]=i;
   }
   printf("\n\n\t No.of page faults...%d",pf);
   getch();
}
int lruvictim()
{
  int i,j,temp1,temp2;
  for(i=0;i<nof;i++)
  {
    temp1=frm[i];
    lrucal[i]=recent[temp1];
  }
  temp2=lrucal[0];
  for(j=1;j<nof;j++)
  {
    if(temp2>lrucal[j])
    temp2=lrucal[j];
  }
  for(i=0;i<nof;i++)
  if(ref[temp2]==frm[i])
  return i;
  return 0;
}








Actual output:
                         
                       LRU PAGE REPLACEMENT ALGORITHM
Enter no.of Frames....3
Enter no.of reference string..6
Enter reference string..6 5 4 2 3 1
                 LRU PAGE REPLACEMENT ALGORITHM 
The given reference string:          ………………….  6   5   4   2   3   1
         Reference NO 6->          6  -1  -1
         Reference NO 5->          6   5  -1
         Reference NO 4->          6   5   4
         Reference NO 2->          2   5   4
         Reference NO 3->          2   3   4
         Reference NO 1->          2   3   1
         No.of page faults...6














Aim: (C.) Simulate the LFU Page Replacement Algorithm
Algorithm:
Step 1:  Create a array
Step 2:  When the page fault occurs replace page that will not be used for the longest 
                period of time

Excepted output:
                            OPTIMAL PAGE REPLACEMENT ALGORITHM
Enter no.of Frames....3
Enter no.of reference string..6
Enter reference string..6 5 4 2 3 1
                 OPTIMAL PAGE REPLACEMENT ALGORITHM 
         The given reference string ………………….  6   5   4   2   3   1
         Reference NO 6->          6  -1  -1
         Reference NO 5->          6   5  -1
         Reference NO 4->          6   5   4
         Reference NO 2->          2   5   4
         Reference NO 3->          2   3   4
         Reference NO 1->          2   3   1

         No.of page faults...6








Source code:
#include<stdio.h>
#include<conio.h>
int i,j,nof,nor,flag=0,ref[50],frm[50],pf=0,victim=-1;
int recent[10],optcal[50],count=0;
int optvictim();
void main()
{
   clrscr();
   printf("\n OPTIMAL PAGE REPLACEMENT ALGORITHN");
   printf("\n.................................");
   printf("\nEnter the no.of frames");
   scanf("%d",&nof);
   printf("Enter the no.of reference string");
   scanf("%d",&nor);
   printf("Enter the reference string");
   for(i=0;i<nor;i++)
       scanf("%d",&ref[i]);
   clrscr();
   printf("\n OPTIMAL PAGE REPLACEMENT ALGORITHM");
   printf("\n................................");
   printf("\nThe given string");
   printf("\n....................\n");
   for(i=0;i<nor;i++)
       printf("%4d",ref[i]);
   for(i=0;i<nof;i++)
   {
       frm[i]=-1;
       optcal[i]=0; }
   for(i=0;i<10;i++)
       recent[i]=0;
   printf("\n");
   for(i=0;i<nor;i++)
   {
      flag=0;
      printf("\n\tref no %d ->\t",ref[i]);
      for(j=0;j<nof;j++)
      {
	if(frm[j]==ref[i])
	{
	   flag=1;
	   break;
	}
      }
      if(flag==0)
      {
	count++;
	if(count<=nof)
	    victim++;
	else
	    victim=optvictim(i);
	pf++;
	frm[victim]=ref[i];
	for(j=0;j<nof;j++)
	   printf("%4d",frm[j]);
      }
   }
   printf("\n Number of page faults: %d",pf);
   getch();
}
int optvictim(int index)
{
   int i,j,temp,notfound;
   for(i=0;i<nof;i++)
   {
      notfound=1;
      for(j=index;j<nor;j++)
	if(frm[i]==ref[j])
	{
	    notfound=0;
	    optcal[i]=j;
	    break;
	}
      if(notfound==1)
	   return i;
   }
   temp=optcal[0];
   for(i=1;i<nof;i++)
       if(temp<optcal[i])
	   temp=optcal[i];
   for(i=0;i<nof;i++)
       if(frm[temp]==frm[i])
	   return i;
 return 0;
}





Actual output: 
                            OPTIMAL PAGE REPLACEMENT ALGORITHM
Enter no.of Frames....3
Enter no.of reference string..6
Enter reference string..6 5 4 2 3 1
                 OPTIMAL PAGE REPLACEMENT ALGORITHM 
         The given reference string ………………….  6   5   4   2   3   1
         Reference NO 6->          6  -1  -1
         Reference NO 5->          6   5  -1
         Reference NO 4->          6   5   4
         Reference NO 2->          2   5   4
         Reference NO 3->          2   3   4
         Reference NO 1->          2   3   1

         No.of page faults...6











Experiment 7:
Simulate the Following File Allocation Strategies 
Aim: (A.) Simulate the Sequenced File Allocation Strategies.
Algorithm:
Step 1: Start the program.
Step 2: Get the number of memory partition and their sizes.
Step 3: Get the number of processes and values of block size for each process.
Step 4: First fit algorithm searches all the entire memory block until a hole which is     
              big enough is encountered. It allocates that memory block for the requesting 
              process.
Step 5: Best-fit algorithm searches the memory blocks for the smallest hole which can 
              be allocated to requesting process and allocates if.
Step 6: Worst fit algorithm searches the memory blocks for the largest hole and 
               allocates it to the process.
Step 7: Analyses all the three memory management techniques and display the best 
            algorithm which utilizes the memory resources effectively and efficiently.
Step 8: Stop the program.

Expected output:
Enter no.of files: 2                                                             
Enter no. of blocks occupied by file1 4                                          
Enter the starting block of file1 2                                             
 Enter no. of blocks occupied by file2 10                                         
Enter the starting block of file2 5                                              
Filename        Start block     length                                         
 1                         2                    4                                                               
2                          5                    10                                                              
Enter file name: rajesh                                                         
 File name is:12803 length is:0blocks occupied   
Source code:
#include<stdio.h>
#include<conio.h>
main()
{
 int n,i,j,b[20],sb[20],t[20],x,c[20][20];
 clrscr();
 printf("Enter no.of files:");
 scanf("%d",&n);
 for(i=0;i<n;i++)
 {
	printf("Enter no. of blocks occupied by file%d",i+1);
	scanf("%d",&b[i]);
	printf("Enter the starting block of file%d",i+1);
	scanf("%d",&sb[i]);
	t[i]=sb[i];
	for(j=0;j<b[i];j++)
		c[i][j]=sb[i]++;
	}
 printf("Filename\tStart block\tlength\n");
 for(i=0;i<n;i++)
	printf("%d\t  %d \t%d\n",i+1,t[i],b[i]);
 printf("Enter file name:");
 scanf("%d",&x);
 printf("File name is:%d",x);
 printf("length is:%d",b[x-1]);
 printf("blocks occupied:");
 for(i=0;i<b[x-1];i++)
	printf("%4d",c[x-1][i]);
 getch();
}


Actual output:

Enter no.of files: 2                                                             
Enter no. of blocks occupied by file1 4                                          
Enter the starting block of file1 2                                             
 Enter no. of blocks occupied by file2 10                                         
Enter the starting block of file2 5                                              
Filename        Start block     length                                         
 1                         2                    4                                                               
2                          5                    10                                                              
Enter file name: rajesh                                                         
 File name is:12803 length is:0blocks occupied   













Aim: (B.) Simulate the Indexed File Allocation Strategies.
Algorithm:
Step 1:  Start.
Step 2:  Let n be the size of the buffer
Step 3:	 check if there are any producer
Step 4:	 if yes check whether the buffer is full
Step 5:	 If no the producer item is stored in the buffer
Step 6:  If the buffer is full the producer has to wait
Step 7:  Check there is any cosumer.If yes check whether the buffer is empty 
Step 8:  If no the consumer consumes them from the buffer
Step 9:  If the buffer is empty, the consumer has to wait.
Step 10: Repeat checking for the producer and consumer till required
Step 11: Terminate the process.










Expected output:
Enter no. of files:2                                                           
 Enter starting block and size of file1: 2   5                                      
Enter blocks occupied by file1:10                                               
enter blocks of file1:3  2  5   4  6  7   2   6  4  7                                                                               
Enter starting block and size of file2: 3   4                                      
Enter blocks occupied by file2:5                                                
enter blocks of file2: 2  3   4  5   6                                                                                                                                                               File     index  length                                                         
 1       2       10                                                              
2       3       5                                        
 Enter file name: venkat                                                          
file name is:12803                                                              











Source code:
#include<stdio.h>
#include<conio.h>
main()
{
 int n,m[20],i,j,sb[20],s[20],b[20][20],x;
 clrscr();
 printf("Enter no. of files:");
 scanf("%d",&n);
 for(i=0;i<n;i++)
 {	printf("Enter starting block and size of file%d:",i+1);
	scanf("%d%d",&sb[i],&s[i]);
	printf("Enter blocks occupied by file%d:",i+1);
	scanf("%d",&m[i]);
	printf("enter blocks of file%d:",i+1);
	for(j=0;j<m[i];j++)
		scanf("%d",&b[i][j]);
 } printf("\nFile\t index\tlength\n");
 for(i=0;i<n;i++)
 {
	printf("%d\t%d\t%d\n",i+1,sb[i],m[i]);
 }printf("\nEnter file name:");
 scanf("%d",&x);
 printf("file name is:%d\n",x);
 i=x-1;
 printf("Index is:%d",sb[i]);
 printf("Block occupied are:");
 for(j=0;j<m[i];j++)
	printf("%3d",b[i][j]);
 getch();
}
Actual output:
Enter no. of files:2                                                           
 Enter starting block and size of file1: 2   5                                      
Enter blocks occupied by file1:10                                               
enter blocks of file1:3                                                         
2  5   4  6  7   2   6  4  7                                                                               
Enter starting block and size of file2: 3   4                                      
Enter blocks occupied by file2:5                                                
enter blocks of file2: 2  3   4  5   6                                                                                                                                                               File     index  length                                                         
 1       2       10                                                              
2       3       5                                                                                                                                               
Enter file name: venkat                                                          
file name is:12803                                                              


Aim: (C.) Simulate the Linked File Allocation Strategies.
Algorithm:
Step 1:  Create a queue to hold all pages in memory
Step 2:  When the page is required replace the page at the head of the queue
Step 3:  Now the new page is inserted at the tail of the queue
Step 4:  Create a stack
Step 5:  When the page fault occurs replace page present at the bottom of the stack
Step 6: Stop the allocation.

Expected output:
Enter no. of files:2                                                            
Enter file name:venkat                                                         
Enter starting block:20                                                         
Enter no.of blocks:6                                                           
Enter block numbers: 4     12       15     45     32      25                                                                              
Enter file name:rajesh                                                          
Enter starting block:12                                                         
Enter no.of blocks:5                                                            
Enter block numbers:6                                                           
5                                                                               
4                                                                               
3                                                                               
2                                                                               
File    start   size    block                                                   
venkat  20      6       4--->12--->15--->45--->32--->25                         
rajesh  12      5       6--->5--->4--->3--->2  


Source code:
#include<stdio.h>
#include<conio.h>
struct file
{
 char fname[10];
 int start,size,block[10];
}f[10];
main()
{
 int i,j,n;
 clrscr();
 printf("Enter no. of files:");
 scanf("%d",&n);
 for(i=0;i<n;i++)
 {
 printf("Enter file name:");
 scanf("%s",&f[i].fname);
 printf("Enter starting block:"); ki
 scanf("%d",&f[i].start);
 f[i].block[0]=f[i].start;
 printf("Enter no.of blocks:");
 scanf("%d",&f[i].size);
 printf("Enter block numbers:");
 for(j=1;j<=f[i].size;j++)
 {
	scanf("%d",&f[i].block[j]);
 }
 }
 printf("File\tstart\tsize\tblock\n");
 for(i=0;i<n;i++)
 {
	printf("%s\t%d\t%d\t",f[i].fname,f[i].start,f[i].size);
	for(j=1;j<=f[i].size-1;j++)
		printf("%d--->",f[i].block[j]);
	printf("%d",f[i].block[j]);
	printf("\n");
 }
 getch();
}


















Actual output:
Enter no. of files:2                                                            
Enter file name:venkat                                                         
Enter starting block:20                                                         
Enter no.of blocks:6                                                           
Enter block numbers: 4                                                           
12                                                                              
15                                                                              
45                                                                              
32                                                                              
25                                                                              
Enter file name:rajesh                                                          
Enter starting block:12                                                         
Enter no.of blocks:5                                                            
Enter block numbers:6                                                           
5                                                                               
4                                                                               
3                                                                               
2                                                                               
File    start   size    block                                                   
venkat  20      6       4--->12--->15--->45--->32--->25                         
rajesh  12      5       6--->5--->4--->3--->2      






Uinux Lab


1.Write shell program to check whether the given number is prime or not

echo "enter a number"
read num
i=2
flag=0
while [ $i -lt $num ]
do
   if [ `expr $num % 2` -eq 0 ]
    then
    flag=1
    fi
    i=`expr $i + 1`
 done
if [ $flag -eq 0 ]
then
  echo "given number is prime"
else
  echo "given unmber is not a prime"
fi

OUTPUT

                    












2. //shell program to check print fibonacci sequence with in the given range 

echo "enter the range"
read n
a=0
b=1
echo $a
echo $b
c=0
c=`expr $a + $b`
while [ $c -lt $n ]
do
 echo $c
 a=$b
 b=$c
  c=`expr $a + $b`
 done

OUTPUT

                       














3. //shell program to check whether the given string is palindrome or not

echo "Enter a string"
read str
len=`echo $str | wc -c`
len=`expr $len - 1`
i=1
j=`expr $len / 2`
while [ $i -le $j ]
do
k=`echo $str | cut -c $i`
l=`echo $str | cut -c $len`
if [ $k != $l ]
then
echo "String is not palindrome"
exit
fi
i=`expr $i + 1`
len=`expr $len - 1`
done
echo "String is palindrome"

OUTPUT

                        














4. // shell program to find the grade of students 
echo "enter your name and number"
read name num
echo "enter your five subjects marks"
read sub1
read sub2
read sub3
read sub4
read sub5
total=`expr $sub1 + $sub2 + $sub3 + $sub4 + $sub5`
avg=`expr $total / 5`
echo "$name \t $num"
if [ $avg -ge 80 ]
then
echo "grade A"
elif [ $avg -ge 70 -a $avg -lt 80  ]
then
echo "grade B"
elif [ $avg -ge 60 -a $avg -lt 70 ]
then
echo "grade C"
elif [ $avg -ge 50 -a $avg -lt 60 ]
then
echo "grade D"
elif  [ $avg -ge 40 -a $avg -lt 50 ]
then
echo " grade E"
else
echo "grade F"
fi
OUTPUT
                                   







5. // shell program to check whether the given number is armstrong or not
echo "enter a number"
read c

x=$c
sum=0
r=0
n=0
while [ $x -gt 0 ]
do
r=`expr $x % 10`
n=`expr $r \* $r \* $r`
sum=`expr $sum + $n`
x=`expr $x / 10`
done
if [ $sum -eq $c ]
then
echo "armstrong number"
else
echo "not armstrong number"
fi

OUTPUT

                                        











6. //shell program to print the ncr values
fact()
{
  i=1
  a=1
  while [ $i -le $x ]
  do
   a=`expr $a \* $i`
   i=`expr $i + 1`
  done
}
echo "enter the n value"
 read n
echo "enter the r value"
 read r
 x=$n
 fact
 nf=$a

 x=$r
 fact
 rf=$a
 x=`expr $n - $r`
 rf=$a
 fact
nrf=$a
 den=`expr $rf \* $nrf`
  res=`expr $nf / $den`
echo $res
  OUTPUT                                              
                                          



7. //shell program to check whether the give number is palindrome or not
echo "Enter any number"
read num
m=`expr $num`
sum=0
while [ $num -gt 0 ]
do
r=`expr $num % 10`
sum=`expr $sum \* 10 + $r`
num=`expr $num / 10`
done
if [ $m -eq $sum ]
then
echo "Given number is palindrome"
else
echo "The number is not palindrome"
fi
OUTPUT



                                     












8.//shell program to fin min and max elements in a array
echo "Enter your range"
read n
i=0
echo "Enter the elements"
while [ $i -lt $n ]
do
 read num
 eval arr$i=$num
 i=`expr $i + 1`
done
i=0
eval min=\$arr$i
eval max=\$arr$i
i=1
while [ $i -lt $n ]
do
 eval t=\$arr$i
 if [ $t -lt $min ]
 then
  min=$t
  elif [ $t -gt $max ]
 then
  max=$t
 fi
 i=`expr $i + 1`
done
echo "The minimum value of the array is $min"
echo "The maximum value of the array is $max"
OUTPUT
                               
